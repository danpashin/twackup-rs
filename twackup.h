/*! \file */
/*******************************************
 *                                         *
 *  File auto-generated by `::safer_ffi`.  *
 *                                         *
 *  Do not manually edit this file.        *
 *                                         *
 *******************************************/

#ifndef __RUST_TWACKUP__
#define __RUST_TWACKUP__

#ifdef __cplusplus
extern "C" {
#endif


#include <stdbool.h>

typedef struct TwDpkg {

    void * dpkg_ptr;

    void * runtime_ptr;

} TwDpkg_t;

/** \brief
 *  Initialises dpkg database parser
 * 
 *  \param[in] dpkg_dir Path to dpkg directory
 *  \param[in] lock If dpkg database dir must be locked for parsing packages
 * 
 */
TwDpkg_t * tw_init (
    char const * dpkg_dir,
    bool lock);

/** \brief
 *  Deallocates dpkg instance
 * 
 *  \param[in] dpkg Instance to be deallocated
 * 
 */
void tw_free (
    TwDpkg_t * dpkg);


#include <stddef.h>
#include <stdint.h>

/** \remark Has the same ABI as `uint8_t` **/
#ifdef DOXYGEN
typedef enum TwPackagesSort
#else
typedef uint8_t TwPackagesSort_t; enum
#endif
{
    /** . */
    TW_PACKAGES_SORT_UNSORTED,
    /** . */
    TW_PACKAGES_SORT_IDENTIFIER,
    /** . */
    TW_PACKAGES_SORT_NAME,
}
#ifdef DOXYGEN
TwPackagesSort_t
#endif
;

typedef void *TwPackageRef;
/** \brief
 *  Like [`slice_ref`] and [`slice_mut`], but with any lifetime attached
 *  whatsoever.
 * 
 *  It is only intended to be used as the parameter of a **callback** that
 *  locally borrows it, due to limitations of the [`ReprC`][
 *  `trait@crate::layout::ReprC`] design _w.r.t._ higher-rank trait bounds.
 * 
 *  # C layout (for some given type T)
 * 
 *  ```c
 *  typedef struct {
 *      // Cannot be NULL
 *      T * ptr;
 *      size_t len;
 *  } slice_T;
 *  ```
 * 
 *  # Nullable pointer?
 * 
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_raw_uint8 {

    uint8_t * ptr;

    size_t len;

} slice_raw_uint8_t;

/** \remark Has the same ABI as `uint8_t` **/
#ifdef DOXYGEN
typedef enum TwPackageSection
#else
typedef uint8_t TwPackageSection_t; enum
#endif
{
    /** \brief
     *  Other not listed package sections
     */
    TW_PACKAGE_SECTION_OTHER = 0,
    /** \brief
     *  Different archiving utils
     */
    TW_PACKAGE_SECTION_ARCHIVING,
    /** \brief
     *  Developers header files and etc.
     */
    TW_PACKAGE_SECTION_DEVELOPMENT,
    /** \brief
     *  Utils for use with network
     */
    TW_PACKAGE_SECTION_NETWORKING,
    /** \brief
     *  Other archiving utils
     */
    TW_PACKAGE_SECTION_PACKAGING,
    /** \brief
     *  System packages
     */
    TW_PACKAGE_SECTION_SYSTEM,
    /** \brief
     *  Terminal
     */
    TW_PACKAGE_SECTION_TERMINAL_SUPPORT,
    /** \brief
     *  Text editors
     */
    TW_PACKAGE_SECTION_TEXT_EDITORS,
    /** \brief
     *  Themes
     */
    TW_PACKAGE_SECTION_THEMES,
    /** \brief
     *  Tweaks
     */
    TW_PACKAGE_SECTION_TWEAKS,
    /** \brief
     *  Different utilities
     */
    TW_PACKAGE_SECTION_UTILITIES,
}
#ifdef DOXYGEN
TwPackageSection_t
#endif
;

/** \brief
 *  dpkg current package state
 */
/** \remark Has the same ABI as `uint8_t` **/
#ifdef DOXYGEN
typedef enum TwPackageSelectionState
#else
typedef uint8_t TwPackageSelectionState_t; enum
#endif
{
    /** \brief
     *  The package selection is unknown. A package that is also
     *  in a not-installed state, and with an ok flag will be
     *  forgotten in the next database store.
     */
    TW_PACKAGE_SELECTION_STATE_UNKNOWN,
    /** \brief
     *  The package is selected for installation
     */
    TW_PACKAGE_SELECTION_STATE_INSTALL,
    /** \brief
     *  Such a package is not handled by dpkg
     */
    TW_PACKAGE_SELECTION_STATE_HOLD,
    /** \brief
     *  The package is marked for deinstallation.
     *  The configuration will be kept
     */
    TW_PACKAGE_SELECTION_STATE_DE_INSTALL,
    /** \brief
     *  The package is marked for deinstallation.
     *  The configuration will be removed, too
     */
    TW_PACKAGE_SELECTION_STATE_PURGE,
}
#ifdef DOXYGEN
TwPackageSelectionState_t
#endif
;

/** \brief
 *  dpkg-set flags for package
 */
/** \remark Has the same ABI as `uint8_t` **/
#ifdef DOXYGEN
typedef enum TwPackageStatusFlag
#else
typedef uint8_t TwPackageStatusFlag_t; enum
#endif
{
    /** \brief
     *  A package marked ok is in a known state,
     *  but might need further processing.
     */
    TW_PACKAGE_STATUS_FLAG_OK,
    /** \brief
     *  A package marked reinstreq is broken and requires installation
     */
    TW_PACKAGE_STATUS_FLAG_RE_INSTALL_REQUEST,
}
#ifdef DOXYGEN
TwPackageStatusFlag_t
#endif
;

/** \brief
 *  dpkg-set current package state
 */
/** \remark Has the same ABI as `uint8_t` **/
#ifdef DOXYGEN
typedef enum TwPackageCurrentState
#else
typedef uint8_t TwPackageCurrentState_t; enum
#endif
{
    /** \brief
     *  The package is not installed on a system
     */
    TW_PACKAGE_CURRENT_STATE_NOT_INSTALLED,
    /** \brief
     *  Only a packages configuration files exist on a system
     */
    TW_PACKAGE_CURRENT_STATE_CONFIG_FILES,
    /** \brief
     *  An installation of a package was started, but not finished
     */
    TW_PACKAGE_CURRENT_STATE_HALF_INSTALLED,
    /** \brief
     *  The package is unpacked but not configured
     */
    TW_PACKAGE_CURRENT_STATE_UNPACKED,
    /** \brief
     *  The package is unpacked and its configuration was started, but not finished
     */
    TW_PACKAGE_CURRENT_STATE_HALF_CONFIGURED,
    /** \brief
     *  The package awaits trigger processing by another package
     */
    TW_PACKAGE_CURRENT_STATE_TRIGGERS_AWAITED,
    /** \brief
     *  The package has been triggered
     */
    TW_PACKAGE_CURRENT_STATE_TRIGGERS_PENDING,
    /** \brief
     *  The package is correctly unpacked and configured
     */
    TW_PACKAGE_CURRENT_STATE_INSTALLED,
}
#ifdef DOXYGEN
TwPackageCurrentState_t
#endif
;

typedef struct TwPackageState {

    TwPackageSelectionState_t selection_state;

    TwPackageStatusFlag_t status_flag;

    TwPackageCurrentState_t current_state;

} TwPackageState_t;

/** \brief
 *  Package priority
 */
/** \remark Has the same ABI as `uint8_t` **/
#ifdef DOXYGEN
typedef enum TwPackagePriority
#else
typedef uint8_t TwPackagePriority_t; enum
#endif
{
    /** . */
    TW_PACKAGE_PRIORITY_NOT_SPECIFIED = 0,
    /** \brief
     *  Package is optional for installation and removal
     */
    TW_PACKAGE_PRIORITY_OPTIONAL,
    /** \brief
     *  Package is required for system to work
     */
    TW_PACKAGE_PRIORITY_REQUIRED,
    /** \brief
     *  Package is important for installed system
     */
    TW_PACKAGE_PRIORITY_IMPORTANT,
    /** \brief
     *  Package is shipped with default priority
     */
    TW_PACKAGE_PRIORITY_STANDARD,
    /** \brief
     *  Package is important for installed system
     */
    TW_PACKAGE_PRIORITY_EXTRA,
}
#ifdef DOXYGEN
TwPackagePriority_t
#endif
;

/** \brief
 *  Describes field type
 */
/** \remark Has the same ABI as `uint8_t` **/
#ifdef DOXYGEN
typedef enum TwPackageField
#else
typedef uint8_t TwPackageField_t; enum
#endif
{
    /** \brief
     *  The value of this field determines the package name, and
     *  is used to generate file names by most installation tools
     */
    TW_PACKAGE_FIELD_PACKAGE,
    /** \brief
     *  Typically, this is the original package's version number
     *  in whatever form the program's author uses. It may also
     *  include a Debian revision number (for non-native packages).
     */
    TW_PACKAGE_FIELD_VERSION,
    /** \brief
     *  The architecture specifies which type of hardware this
     *  package was compiled for.
     */
    TW_PACKAGE_FIELD_ARCHITECTURE,
    /** \brief
     *  This field is used to indicate how this package should
     *  behave on a multi-arch installations.
     */
    TW_PACKAGE_FIELD_MULTI_ARCH,
    /** \brief
     *  This is a general field that gives the package a category
     *  based on the software that it installs
     */
    TW_PACKAGE_FIELD_SECTION,
    /** \brief
     *  The format for the package description is a short brief
     *  summary on the first line (after the Description field).
     *  The following lines should be used as a longer, more
     *  detailed description. Each line of the long description
     *  must be preceded by a space, and blank lines in the long
     *  description must contain a single ‘.’ following the
     *  preceding space
     */
    TW_PACKAGE_FIELD_DESCRIPTION,
    /** \brief
     *  author of the software that was packaged
     */
    TW_PACKAGE_FIELD_AUTHOR,
    /** \brief
     *  The person who created the package
     */
    TW_PACKAGE_FIELD_MAINTAINER,
    /** \brief
     *  The upstream project home page url
     */
    TW_PACKAGE_FIELD_HOMEPAGE,
    /** \brief
     *  Denotes a package that is required for proper operation of the system
     */
    TW_PACKAGE_FIELD_ESSENTIAL,
    /** \brief
     *  Current installation status
     */
    TW_PACKAGE_FIELD_STATUS,
    /** \brief
     *  The approximate total size of the package's installed
     *  files, in KiB units
     */
    TW_PACKAGE_FIELD_INSTALLED_SIZE,
    /** \brief
     *  Sets the importance of this package in relation to the
     *  system as a whole.
     */
    TW_PACKAGE_FIELD_PRIORITY,
    /** \brief
     *  List of packages that are required for this package to
     *  provide a non-trivial amount of functionality.
     */
    TW_PACKAGE_FIELD_DEPENDS,
    /** \brief
     *  List of packages that must be installed and configured
     *  before this one can be installed
     */
    TW_PACKAGE_FIELD_PRE_DEPENDS,
    /** \brief
     *  Lists packages that would be found together with this one
     *  in all but unusual installations
     */
    TW_PACKAGE_FIELD_RECOMMENDS,
    /** \brief
     *  Lists packages that are related to this one and can
     *  perhaps enhance its usefulness, but without which
     *  installing this package is perfectly reasonable
     */
    TW_PACKAGE_FIELD_SUGGESTS,
    /** \brief
     *  Lists packages that this one breaks, for example by
     *  exposing bugs when the named packages rely on this one
     */
    TW_PACKAGE_FIELD_BREAKS,
    /** \brief
     *  Lists packages that conflict with this one, for example by
     *  containing files with the same names
     */
    TW_PACKAGE_FIELD_CONFLICTS,
    /** \brief
     *  This is a list of virtual packages that this one provides
     */
    TW_PACKAGE_FIELD_PROVIDES,
    /** \brief
     *  List of packages files from which this one replaces
     */
    TW_PACKAGE_FIELD_REPLACES,
    /** \brief
     *  User-readable name of the package
     */
    TW_PACKAGE_FIELD_NAME,
    /** \brief
     *  Meta-info as os support and etc...
     */
    TW_PACKAGE_FIELD_TAG,
    /** \brief
     *  Like homepage
     */
    TW_PACKAGE_FIELD_DEPICTION,
}
#ifdef DOXYGEN
TwPackageField_t
#endif
;

/** \brief
 *  [`Box`][`rust::Box`]`<[T]>` (fat pointer to a slice),
 *  but with a guaranteed `#[repr(C)]` layout.
 * 
 *  # C layout (for some given type T)
 * 
 *  ```c
 *  typedef struct {
 *      // Cannot be NULL
 *      T * ptr;
 *      size_t len;
 *  } slice_T;
 *  ```
 * 
 *  # Nullable pointer?
 * 
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_boxed_uint8 {

    uint8_t * ptr;

    size_t len;

} slice_boxed_uint8_t;

/** \brief
 *  [`Box`][`rust::Box`]`<[T]>` (fat pointer to a slice),
 *  but with a guaranteed `#[repr(C)]` layout.
 * 
 *  # C layout (for some given type T)
 * 
 *  ```c
 *  typedef struct {
 *      // Cannot be NULL
 *      T * ptr;
 *      size_t len;
 *  } slice_T;
 *  ```
 * 
 *  # Nullable pointer?
 * 
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_boxed_slice_raw_uint8 {

    slice_raw_uint8_t * ptr;

    size_t len;

} slice_boxed_slice_raw_uint8_t;

/** \brief
 *  fff TWPACKAGE
 */
typedef struct TwPackage {

    TwPackageRef inner_ptr;

    slice_raw_uint8_t identifier;

    slice_raw_uint8_t name;

    slice_raw_uint8_t version;

    TwPackageSection_t section;

    TwPackageState_t state;

    TwPackagePriority_t priority;

    slice_raw_uint8_t (*get_section_string)(TwPackageRef package_ref);

    slice_raw_uint8_t (*get_field)(TwPackageRef package_ref, TwPackageField_t);

    slice_boxed_uint8_t (*build_control)(TwPackageRef package_ref);

    slice_boxed_slice_raw_uint8_t (*get_dependencies)(TwPackageRef package_ref);

} TwPackage_t;

/** \brief
 *  [`Box`][`rust::Box`]`<[T]>` (fat pointer to a slice),
 *  but with a guaranteed `#[repr(C)]` layout.
 * 
 *  # C layout (for some given type T)
 * 
 *  ```c
 *  typedef struct {
 *      // Cannot be NULL
 *      T * ptr;
 *      size_t len;
 *  } slice_T;
 *  ```
 * 
 *  # Nullable pointer?
 * 
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_boxed_TwPackage {

    TwPackage_t * ptr;

    size_t len;

} slice_boxed_TwPackage_t;

/** \brief
 *  Fetches packages from dpkg database
 * 
 *  \param[in] dpkg Dpkg instance
 *  \param[in] leaves_only If parser should return leaves packages or not
 *  \param[in] sort Sort type. Select TW_PACKAGES_SORT_UNSORTED if no sort is needed
 * 
 */
slice_boxed_TwPackage_t tw_get_packages (
    TwDpkg_t const * dpkg,
    bool leaves_only,
    TwPackagesSort_t sort);

/** \brief
 *  Returns package section description
 * 
 *  \param[in] package package instance
 *  from which section description should be fetched
 * 
 */
slice_raw_uint8_t tw_get_package_section_string (
    TwPackageRef package);

/** \brief
 *  Fetches package field value
 * 
 *  \param[in] package Package from which field value should be fetched
 *  \param[in] field Field type
 * 
 */
slice_raw_uint8_t tw_get_package_field (
    TwPackageRef package,
    TwPackageField_t field);

/** \brief
 *  Build control file string from package
 * 
 *  \param[in] package Package from which control string should be build
 * 
 */
slice_boxed_uint8_t tw_package_build_control (
    TwPackageRef package);


#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* __RUST_TWACKUP__ */
